/*
Specification for Construction V.1 From 'Onion Franking: Abuse Reports for Mix-Based Private Messaging'
======================================

Authors: 	    Sarah Haddix
Date: 	        April, 2025

*/

/*
  Questions:
  How to model n servers?
  Is the current way I model PRG G alright? - subterm convergence warning
    also just like make sure fst(scd ) thing like works
  Send action fact causing infinite loading stuff
*/

theory ConstructionV1
begin

builtins: asymmetric-encryption, symmetric-encryption, xor, hashing

functions: Equals/2, true/0
functions: G/1 
functions: kf_/1, r1_/1, r2_/1, r3_/1, r4_/1
functions: Com_Commit/2, Com_Open/3
functions: Mac_Sign/2, Mac_Verify/3
functions: sdec_/2, senc_/2

// PRG G in construction V.1
// can't determine s from any of these
//equations: G(s) = <kf_(s), r1_(s), r2_(s), r3_(s), r4_(s)>   
// TODO - fix this, just experimenting
equations: G(<s, s, s, s, s>) = <s, s, s, s, s>

// implementation of Com.Commit(r,m) and Com.Open(c,m,r)
equations: Com_Open(Com_Commit(r,m), m, r) = true
// implementation of Mac_Sign(k, m) and Mac_Verify(k, m, sigma)
equations: Mac_Verify(k, m, Mac_Sign(k, m)) = true

equations: Equals(x, x) = true 


rule GenerateSymmetricKey: [Fr(~kr)] --> [!SymmetricKey($S, $R, ~kr)]

// Generate n=4 servers, moderator key ~km, associate them with a network ID
rule GenerateOnionServerNetwork: 
  let
    pk1 = pk(~sk1)
    pk2 = pk(~sk2)
    pk3 = pk(~sk3)
    pk4 = pk(~sk4)
  in
  [ Fr(~sk1), Fr(~sk2), Fr(~sk3), Fr(~sk4), Fr(~km), Fr(~net_id) ] 
  --> 
  [ 
    !OnionServerSkAssoc($S1, ~sk1), !OnionServerPkAssoc($S1, pk1), Out(pk1),
    !OnionServerSkAssoc($S2, ~sk2), !OnionServerPkAssoc($S2, pk2), Out(pk2),
    !OnionServerSkAssoc($S3, ~sk3), !OnionServerPkAssoc($S3, pk3), Out(pk3),
    !OnionServerSkAssoc($S4, ~sk4), !OnionServerPkAssoc($S4, pk4), Out(pk4),
    !ModeratorKey($M, ~km),
    !OnionServerNetwork($S1, $S2, $S3, $S4, $M, ~net_id)
  ]

// Restriction that we only ever have one onion network at once. 
// We want to be able to send multiple messages over the same server configuration
// Takes in net_id - this assertion is made in the Send function
restriction SingleNetwork:
  "All x y #i #j . SingleNetwork(x)@#i & SingleNetwork(y)@#j ==> x=y"


// The send rule models sending a message through the entire network, including all of the onion servers
rule Send:
  let
    // ****** SEND FUNCTION ******
    kf = fst(G(~s, ~s, ~s, ~s, ~s))
    r1 = fst(snd(G(~s, ~s, ~s, ~s, ~s)))
    r2 = fst(snd(snd(G(~s, ~s, ~s, ~s, ~s))))
    r3 = fst(snd(snd(snd(G(~s, ~s, ~s, ~s, ~s)))))
    r4 = fst(snd(snd(snd(snd(G(~s, ~s, ~s, ~s, ~s))))))
    c1m = senc(~m, kr) // cyphertext
    c1s = senc(~s, kr) // cyphertext
    c2 = Com_Commit(kf, ~m) // cyphertext commitment / franking tag
    c34 = aenc(<'e', r4>, pk4) // e for empty
    c33 = aenc(<c34, r3>, pk3)
    c32 = aenc(<c33, r2>, pk2)
    c31 = aenc(<c32, r1>, pk1)
    c3 = c31 // mixnet franking packet - holds ri for each server
    // ***************************
    // ****** Onion.Encrypt ******
    // encrypt c1 with vec(pk)
    ctm0 = aenc(aenc(aenc(aenc(c1m, pk4), pk3), pk2), pk1)
    cts0 = aenc(aenc(aenc(aenc(c1s, pk4), pk3), pk2), pk1)
    // ***************************
    // ****** ModProcess *********
    sigma = Mac_Sign(~km, <c2, ~ctx>)
    sigma_c = h(<sigma, c2, ~ctx>)
    // st0 = <c2, sigma, sigma_c, ~ctx>
    // ***************************
    // ******* Onion.Peel ********
    // path of the cyphertext through the onion encryption scheme
    ctm1 = adec(ctm0, pk1)
    cts1 = adec(cts0, pk1)
    ctm2 = adec(ctm1, pk2)
    cts2 = adec(cts1, pk2)
    ctm3 = adec(ctm2, pk3)
    cts3 = adec(cts2, pk3)
    ctm4 = adec(ctm3, pk4) // should just be c1m
    cts4 = adec(cts3, pk4) // should just be c1s
    // ***************************
    // ******** Process **********
    // path of the metadata through the onion encryption scheme
    st1_c2 = c2 XOR r1
    st1_sigma = sigma XOR r1
    st1_sigma_c = sigma_c XOR r1
    st1_ctx = ~ctx XOR r1
    
    st2_c2 = st1_c2 XOR r2
    st2_sigma = st1_sigma XOR r2
    st2_sigma_c = st1_sigma_c XOR r2
    st2_ctx = st1_ctx XOR r2

    st3_c2 = st2_c2 XOR r3
    st3_sigma = st2_sigma XOR r3
    st3_sigma_c = st2_sigma_c XOR r3
    st3_ctx = st2_ctx XOR r3

    st4_c2 = st3_c2 XOR r4
    st4_sigma = st3_sigma XOR r4
    st4_sigma_c = st3_sigma_c XOR r4
    st4_ctx = st3_ctx XOR r4
    // ***************************
  in
  [
    // ***** SETUP/PRECONDITONS FOR A MESSAGE TO BE SENT *****
    // onion server setup has happened
    !OnionServerNetwork($S1, $S2, $S3, $S4, $M, ~net_id),
    !OnionServerSkAssoc($S1, ~sk1), !OnionServerPkAssoc($S1, pk1),
    !OnionServerSkAssoc($S2, ~sk2), !OnionServerPkAssoc($S2, pk2),
    !OnionServerSkAssoc($S3, ~sk3), !OnionServerPkAssoc($S3, pk3),
    !OnionServerSkAssoc($S4, ~sk4), !OnionServerPkAssoc($S4, pk4),
    !ModeratorKey($M, ~km),
    
    // kr has been generated
    !SymmetricKey($S, $R, kr),

    // ***** ***** ***** ***** ***** ***** ***** ***** *****

    // fresh s is generated
    Fr(~s),

    // fresh message is generated
    Fr(~m),

    // fresh ctx is generated - represents the metadata associated with a message
    Fr(~ctx)
  ]

  --[
    SingleNetwork(~net_id),
    MessageSent($S, $R, ~m, ~ctx)
     // TODO - can include information about sender and receiver, something like Sent(<~m, ~s>, $S, $R)
     // TOOD - refine action facts!! these should be able to prove lemmas
  ]->

  [
    Out(<c1s, c1m, c2, c3>), // Send->ModProcess in protocol
    Out(ctm1), // Output of Onion.Peel
    Out(cts1), // Output of Onion.Peel
    Out(ctm2), // Output of Onion.Peel
    Out(cts2), // Output of Onion.Peel
    Out(ctm3), // Output of Onion.Peel
    Out(cts3), // Output of Onion.Peel
    Out(ctm4), // Output of Onion.Peel
    Out(cts4), // Output of Onion.Peel
    Out(st1_c2), // Output of Process server 1
    Out(st1_sigma), // Output of Process server 1
    Out(st1_sigma_c), // Output of Process server 1
    Out(st1_ctx), // Output of Process server 1
    Out(st2_c2), // Output of Process server 2
    Out(st2_sigma), // Output of Process server 2
    Out(st2_sigma_c), // Output of Process server 2
    Out(st2_ctx), // Output of Process server 2
    Out(st3_c2), // Output of Process server 3
    Out(st3_sigma), // Output of Process server 3
    Out(st3_sigma_c), // Output of Process server 3
    Out(st3_ctx), // Output of Process server 3
    Out(st4_c2), // Output of Process server 4
    Out(st4_sigma), // Output of Process server 4
    Out(st4_sigma_c), // Output of Process server 4
    Out(st4_ctx), // Output of Process server 4
    // TODO - should the advarsary be able to see that this comes from S?
    Out(<ctm4, cts4, st4_c2, st4_sigma, st4_sigma_c, st4_ctx>) 
    // ^ becomes input to Read_and_Report, just deconstructed stN and ctN
  ]

  // Models a Receiver who receives and reports an abusive message
  rule Read_and_Report:
  let
    // decrypt c1
    m = sdec(ctmN, ~kr)
    s = sdec(ctsN, ~kr)

    kf = fst(G(s, s, s, s, s))
    r1 = fst(snd(G(s, s, s, s, s)))
    r2 = fst(snd(snd(G(s, s, s, s, s))))
    r3 = fst(snd(snd(snd(G(s, s, s, s, s)))))
    r4 = fst(snd(snd(snd(snd(G(s, s, s, s, s))))))

    // "decrypt" (XOR based) mrt = <c2, ctx, sigma, sigma_c>
    mrt_3_c2 = stN_c2 XOR r4 
    mrt_3_sigma = stN_sigma XOR r4
    mrt_3_sigma_c = stN_sigma_c XOR r4
    mrt_3_ctx = stN_ctx XOR r4
    
    mrt_2_c2 = mrt_3_c2 XOR r3
    mrt_2_sigma = mrt_3_sigma XOR r3
    mrt_2_sigma_c = mrt_3_sigma_c XOR r3
    mrt_2_ctx = mrt_3_ctx XOR r3

    mrt_1_c2 = mrt_2_c2 XOR r2
    mrt_1_sigma = mrt_2_sigma XOR r2
    mrt_1_sigma_c = mrt_2_sigma_c XOR r2
    mrt_1_ctx = mrt_2_ctx XOR r2

    c2 = mrt_1_c2 XOR r1
    sigma = mrt_1_sigma XOR r1
    sigma_c = mrt_1_sigma_c XOR r1
    ctx = mrt_1_ctx XOR r1

  in
  [ 
    In(<ctmN, ctsN, stN_c2, stN_sigma, stN_sigma_c, stN_ctx>),
    !SymmetricKey($S, $R, ~kr)
  ]
  --[ 
    MessageReceived($S, $R, m, ctx) // todo - maybe make this the same as the stuff you're putting on out?
    //Receiver_COM_OPEN(m, ctx, Com_Open(c2, m, kf)), // will be true if message commitment is consistent
    //Receiver_Mac_Hash(m, ctx, ( Equals(sigma_c, h(<sigma, c2, ctx>)) )) // will be true is hash is the same as the hash taken by the moderator
  ]->
  //[ Out(<m, ctx, c2, kf, sigma>) ]
  // [ Out(<m, ctx, c2, sigma>) ]
  // [ Out( 'yeah?' )]
  [ Out( ctx ) ]
  // problem w Out( c2 ) and Out( sigma ) but not Out( ctx )??


  // Process of reporting a message:
  // Out(<m, ctx, c2, kf, sigma>)
  // Existence of T/F com.open and hashing action fact associated with this message
  // Mod ( In(<m, ctx, c2, kf, sigma>) )
  // receives a particular instance of a message, action facts com.open and mac.verify
  // lemma can assert that THAT particular instance, if correctly sent and read, must be correctly reported
  rule Moderate:
  [ 
    !OnionServerNetwork($S1, $S2, $S3, $S4, $M, ~net_id), !ModeratorKey($M, ~km),
    In(<m, ctx, c2, kf, sigma>)
  ]
  --[
    SingleNetwork(~net_id),
    MessageModerated(m, ctx),
    Moderator_COM_OPEN(m, ctx, Com_Open(c2, m, kf)),
    Moderator_MAC_Verify(m, ctx, Mac_Verify(~km, <c2, ctx>, sigma))
    // both of these action facts true => Moderator function returns 1 <=> Report accepted
  ]->
  []
 
  
  lemma Executability:
    exists-trace
    "Ex S R m ctx #t #j #k . MessageSent(S, R, m, ctx)@#t
    & MessageReceived(S, R, m, ctx)@#j
    & MessageModerated(m, ctx)@#k"

  // Lemma saying adversary doesn't know the message and context until the message is reported

  // Whenever we send a message, 
  // if we receive a message, could be 
  // after running messageSend, we want it to be possible to do a messageRead that gives us the same R, m back
  /*
  lemma Correctness_incomplete:
    "All S R m #i . MessageSent(S, R, m)@#i ==> Ex s #j. MessageReceived(R, <m, s>)@#j"
 */
end