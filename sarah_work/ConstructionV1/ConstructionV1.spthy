/*
Specification for Construction V.1 From 'Onion Franking: Abuse Reports for Mix-Based Private Messaging'
======================================

Authors: 	    Sarah Haddix
Date: 	        April, 2025

*/

/*
  Questions:
  How to model n servers?
  Is the current way I model PRG G alright? - subterm convergence warning
*/

theory ConstructionV1
begin

builtins: asymmetric-encryption, symmetric-encryption, xor, hashing

functions: true/0
functions: G/1 
functions: kf_/1, r1_/1, r2_/1, r3_/1, r4_/1
functions: Com_Commit/2, Com_Open/3
functions: Mac_Sign/2, Mac_Verify/3

// PRG G in construction V.1
// can't determine s from any of these
equations: G(s) = <kf_(s), r1_(s), r2_(s), r3_(s), r4_(s)>   

// implementation of Com.Commit(r,m) and Com.Open(c,m,r)
equations: Com_Open(Com_Commit(r,m), m, r) = true
// implementation of Mac_Sign(k, m) and Mac_Verify(k, m, sigma)
equations: Mac_Verify(k, m, Mac_Sign(k, m)) = true

rule GenerateSymmetricKey: [Fr(~kr)] --> [!SymmetricKey($S, $R, ~kr)]

// Generate n=4 servers, moderator key ~km, associate them with a network ID
rule GenerateOnionServerNetwork: 
  let
    pk1 = pk(~sk1)
    pk2 = pk(~sk2)
    pk3 = pk(~sk3)
    pk4 = pk(~sk4)
  in
  [ Fr(~sk1), Fr(~sk2), Fr(~sk3), Fr(~sk4), Fr(~km), Fr(~net_id) ] 
  --> 
  [ 
    !OnionServerSkAssoc($S1, ~sk1), !OnionServerPkAssoc($S1, pk1), Out(pk1),
    !OnionServerSkAssoc($S2, ~sk2), !OnionServerPkAssoc($S2, pk2), Out(pk2),
    !OnionServerSkAssoc($S3, ~sk3), !OnionServerPkAssoc($S3, pk3), Out(pk3),
    !OnionServerSkAssoc($S4, ~sk4), !OnionServerPkAssoc($S4, pk4), Out(pk4),
    !ModeratorKey($M, ~km),
    !OnionServerNetwork($S1, $S2, $S3, $S4, $M, ~net_id)
  ]

// Restriction that we only ever have one onion network at once. 
// We want to be able to send multiple messages over the same server configuration
// Takes in net_id - this assertion is made in the Send function
restriction SingleNetwork:
  "All x #i #j . SingleNetwork(x)@#i & SingleNetwork(x)@#j ==> #i = #j"


// The send rule models sending a message through the entire network, including all of the onion servers
rule Send:
  let
    // ****** SEND FUNCTION ******
    kf = fst(G(~s))
    r1 = fst(snd(G(~s)))
    r2 = fst(snd(snd(G(~s))))
    r3 = fst(snd(snd(snd(G(~s)))))
    r4 = fst(snd(snd(snd(snd(G(~s))))))
    c1 = senc(<~m, ~s>, kr) // cyphertext
    c2 = Com_Commit(kf, ~m) // cyphertext commitment / franking tag
    c34 = aenc(<'e', r4>, pk4) // e for empty
    c33 = aenc(<c34, r3>, pk3)
    c32 = aenc(<c33, r2>, pk2)
    c31 = aenc(<c32, r1>, pk1)
    c3 = c31 // mixnet franking packet - holds ri for each server
    // ***************************
    // ****** Onion.Encrypt ******
    // encrypt c1 with vec(pk)
    
    // ***************************
    // ****** ModProcess *********
    sigma = MAC_Sign(~km, <c2, ~ctx>)
    sigma_c = h(<sigma, c2, ~ctx>)
    st0 = <c2, c3, sigma, sigma_c, ~ctx>
    // ***************************
  in
  [
    // ***** SETUP/PRECONDITONS FOR A MESSAGE TO BE SENT *****
    // onion server setup has happened
    !OnionServerNetwork($S1, $S2, $S3, $S4, $M, ~net_id),
    
    // kr has been generated
    !SymmetricKey($S, $R, kr),

    // ***** ***** ***** ***** ***** ***** ***** ***** *****

    // fresh s is generated
    Fr(~s),

    // fresh message is generated
    Fr(~m),

    // fresh ctx is generated - represents the metadata associated with a message
    Fr(~ctx)
  ]

  --[
    SingleNetwork(~net_id),
    MessageSent($S, $R, ~m)
     // TODO - can include information about sender and receiver, something like Sent(<~m, ~s>, $S, $R)
  ]->

  [
    Out(<c1, c2, c3>), // Send->ModProcess in protocol
    Out(<sigma, sigma_c>), // output of ModProcess
    Out(st0), // output of ModProcess
    Out(c1) // TODO - should the advarsary be able to see that this comes from S? what of the network bundle should the adversary be allowed to see?
  ]

  rule Receiver:
  [ 
    In(c1), // c1 = senc(<~m, ~s>, kr)
    !SymmetricKey($S, $R, ~kr)
  ]
  --[ MessageReceived($R, sdec(c1, ~kr))]->
  []
  
  lemma Executability:
    exists-trace
    "Ex S R m #t . MessageSent(S, R, m)@#t"

  // Whenever we send a message, 
  // if we receive a message, could be 
  // after running messageSend, we want it to be possible to do a messageRead that gives us the same R, m back
  lemma Correctness_incomplete:
    "All S R m #i . MessageSent(S, R, m)@#i ==> Ex s #j. MessageReceived(R, <m, s>)@#j"

end

// use macros to make things more readable?
// probably able to prove more properties as well - thinks like that the server keys aren't leakable? idk

// In() - models taking untrusted stuff in from the network. Doesn't necissarly have to be on the Out() channel already - 
// advarsay can send arbitrary messages