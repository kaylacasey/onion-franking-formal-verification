theory VideoEx
begin

builtins: diffie-hellman
//equations: // WHAT IS THIS
//functions: // WHAT IS THIS - think this could be useful

// Out(pubkey) - makes things visable to the network, makes sure advarsary can see 
// public key
// Identity is a user-defined fact
// after firing this rule, system will store the identity fact
// want premise to be functionally empty, want to create privkey from nothing (randomlly gen)
// A - public. We don't care where it comes from
// ! - persistnat fact. stays
// Fr - fresh
rule create_identities:
    let
        pubkey = 'g'^~privkey
    in
    [Fr(~privkey)]-->[!Identity($A, ~privkey, pubkey), Out(pubkey)]

// client sends pubkey to server
// ! - we want these to stay even after the rule executes
rule client_hello:
    [!Identity($client, ~clientprivkey, clientpubkey), !Identity($server, ~serversk, serverpk)]
    -->
    [Out(<'client_hello', $client, $server, clientpubkey>)]

// DOLLAR SIGN NOT USED - don't want to restrict adversary. message can be from any kind of client
// without the dollar sign, variable on left hand acts as a pattern variable that will be bound to/
// instantiated by the value/variable it is called with
// $ would restrict it to representing a predefined client
// create session between server and client with session key (just part of the protocol they're modling)
rule receive_client_hello:
    let 
        sessionkey = clientpubkey^~serverprivkey
    in
    [!Identity($server, ~serversk, serverpk), In(<'client_hello', client, $server, clientpubkey>)]
    --[ServerCreateSession($server, client, sessionkey)]->
    [Session($server, client, clientpubkey^serverpk), Out(<'server_hello', $server, client, serverpk>)]

rule receiver_server_hello:
    let 
        sessionkey = serverpubkey^~clientprivkey
    in
    [!Identity($client, ~clientprivkey, clientpubkey), In(<'server_hello', server, $client, serverpubkey>)] 
    --[ClientCreateSession($client, server, sessionkey)]->
    [Session($client, server, serverpubkey^~clientprivkey)]

lemma MIM:
all-traces // (default)
"
All client server sessionkey1 sessionkey2 #i #j.
    (
        // If events are true
        // (we don't know if the two sessions will be the same)
        ClientCreateSession(client, server, sessionkey1) @ #i &
        ServerCreateSession(server, client, sessionkey2) @ #j &
        #j < #i &
        not(client = server)
    )
    ==>
    (
        // The adversary never learns the sessionkey1 and 2 together
        // K is a fact (knowing, like arbitrary name tho)
        not(Ex #k1 #k2. K(sessionkey1) @ #k1 & K(sessionkey2) @ #k2)
    )
"

//lemma is false. we don't want adversary to learn the session key. session key is output by client_hello - 
// client_hello outputs to the network clientpubkey='g'^clientprivk

// instance where server1 and server2 are created, have their own public and private keys
// server1 acts as client1, does a client_hello to server2. then, server1 public key = 'g'^~serverprivkey is revealed


// now we know the public keys of client and server? seems

// this is the only importnat part of these comments
// MAN IN THE MIDDLE ATTACK - knows both session keys at once!!! 
// sets up a connection with server and with client, knows both session keys. 
// in the visualization, we need both bubbles. we must know both session keys at once.
// 

// serverkey = clientpubkey^~serverprivkey
// adversary knows clientpubkey because it is output by client_hello
// adversary knows serverprivkey because 



end

// Out(h(k)) means that protocl sent out message h(k) on public channel
// In(x) means protocol receives that message x on public channel

// RULE
// just state transitions
// executing rule means that all the facts in first box must be present. executing
// the rule means they are replaced by the second box

// WAYS TO MAKE THINGS KNOWN TO THE ADVARSARY
// Out(thing)
// public constants - use 'ident', used for agent identities, labels, etc.
// By default, functions are known by the adversary unless declared private

// Notes about proving - round things are adversary