/*
NAXOS MODEL FROM TAMARIN MANUEL
======================================

Authors: 	    Sarah Haddix
Date: 	        April, 2025

*/

theory ConstructionV1
begin

builtins: diffie-hellman
functions: h1/1 
// functions: h2/1 // hashing function for c1
// checksum function? 
// functions: i think use this to define secondary funcs like Com.Open or Onion.Peel and stuff
// functions are public, [private] functions cannot be applied by the advarsary

// x denotes fresh private key, !Ltk fact associates private key and identity, makes persistant
rule Generate_key_pair:
  [ Fr(~x) ]
  -->
  [ !Pk($A,pk(~x))
  , Out(pk(~x))
  , !Ltk($A,~x)
  ]

  rule NaxosR_attempt1:
  [
    In(X),
    Fr(~eskR),
    !Ltk($R, lkR)
  ]
  -->
  [
    Out( 'g'^h1(< ~eskR, lkR >) )
  ]

  // Session key used to discuss security properties later
  rule NaxosR_attempt2:
  [
    In(X),
    Fr(~eskR),
    !Ltk($R, lkR)
  ]
  --[ SessionKey($R, kR ) ]->
  [
    Out( 'g'^h1(< ~eskR, lkR >) )
  ]

  // This definition defines how session key is computed
  // ~tid is used just for thread identification - 
  rule NaxosR_attempt3:
  let
      exR = h1(< ~eskR, lkR >)
      hkr = 'g'^exR
      kR  = h2(< pkI^exR, X^lkR, X^exR, $I, $R >)
  in
   [
       In(X),
       Fr( ~eskR ),
       Fr( ~tid ),
       !Ltk($R, lkR),
       !Pk($I, pkI)
   ]
   --[ SessionKey( ~tid, $R, $I, kR ) ]->
   [
       Out( hkr )
   ]


   // optimization - mark lkR as fresh, since the only way it can possibly be generated is as a
   // fresh value through the keygen function
   rule NaxosR:
  let 
      exR = h1(< ~eskR, ~lkR >)
      hkr = 'g'^exR
      kR  = h2(< pkI^exR, X^~lkR, X^exR, $I, $R >)
  in
   [
       In(X),
       Fr( ~eskR ),
       Fr( ~tid ),
       !Ltk($R, ~lkR),
       !Pk($I, pkI)
   ]
   --[ SessionKey( ~tid, $R, $I, kR ) ]->
   [
       Out( hkr )
   ]

   // Initiator - produces a fresh id so that the next step of the protocol will pick up where
   // this one left off and refer to the values from this specific instance, not of some other
   // thread which is also at the same point in the protocol
   // Init_1 is a fact called a STATE FACT, associates a particular thread with I, R, etc.
   rule NaxosI_1:
  let exI = h1(<~eskI, ~lkI >)
      hkI = 'g'^exI
  in
   [   Fr( ~eskI ),
       Fr( ~tid ),
       !Ltk( $I, ~lkI ) ]
   -->
   [   Init_1( ~tid, $I, $R, ~lkI, ~eskI ),
       Out( hkI ) ]



    rule NaxosI_2:
    let
        exI = h1(< ~eskI, ~lkI >)
        kI  = h2(< Y^~lkI, pkR^exI, Y^exI, $I, $R >)
    in
    [   Init_1( ~tid, $I, $R, ~lkI , ~eskI),
        !Pk( $R, pkR ),
        In( Y ) ]
    --[ SessionKey( ~tid, $I, $R, kI ) ]->
    []


end

// use macros to make things more readable? exist global and local macros